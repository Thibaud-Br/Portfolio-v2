---
title: Publish a package to NPM
date: 30/07/2023
author: Thibaud Brault
cover: /images/publish-to-npm.webp
coverAlt: Publish to NPM
description: Learn how to publish a package to NPM and how to handle versioning
draft: true
category: Tutorial
---

This article is a step-by-step guide on how to publish a package to NPM and how to handle versioning.  
In this article, I will be using GitHub. Please note that some steps may differ if you are using a different hosting service for your repositories.  
I will also be using **Typescript** and **pnpm**. While it's entirely possible to follow along without them, I highly recommend using these tools for an enhanced development experience.

<div>
<h2 class="text-3xl font-redhat mb-3">Prerequisites</h2>

Before you start publishing your NPM package, make sure you have the following prerequisites in place:

<ul class="list-disc">
<li>**Node.js and NPM**: Make sure you have Node.js installed on your system, as it comes bundled with NPM.</li>

<li>**NPM account**: Create an account on the NPM website if you haven't done so already. You'll need this account to publish your package.</li>
</ul>
</div>

<details>
  <summary class="text-2xl text-yellow-600">Table of Contents</summary>
  <ol>
    <li>
      <a href="#1">Step 1: Initialize a Git Repository</a>
    </li>
    <li>
      <a href="#2">Step 2: Initialize NPM</a>
    </li>
    <li>
      <a href="#3">Step 3: Prepare Your Package Files</a>
    </li>
    <li>
      <a href="#4">Step 4: Install Packages</a>
    </li>
    <li>
      <a href="#5">Step 5: Initialize Typescript</a>
    </li>
    <li>
      <a href="#6">Step 6: Add Scripts</a>
    </li>
    <li>
      <a href="#7">Step 7: Add Information About Your Package</a>
    </li>
    <li>
      <a href="#8">Step 8: Initialize `changesets`</a>
    </li>
    <li>
      <a href="#9">Step 9: Add CI with GitHub Actions</a>
    </li>
    <li>
      <a href="#10">
        Step 10: Select The Right Options For Your GitHub Repository
      </a>
    </li>
    <li>
      <a href="#11">Step 11: Publish Your Empty Package</a>
    </li>
    <li>
      <a href="#12">Step 12: Write Your Code</a>
    </li>
    <li>
      <a href="#13">Step 13: Bump The Version</a>
    </li>
  </ol>
</details>

<div>
<h2 class="text-3xl font-redhat mb-3" id="1">Step 1: Initialize a Git Repository</h2>

Create a new project folder and initialize Git inside it by running the following command:

```bash
git init
```

On GitHub, create a new repository and copy its remote url.  
In your project, run the following command to add the remote URL of the newly created repository:

```bash
git remote add <remote name> <copied url>
```

This will allow you to commit and push changes to your repository.

</div>

<div>
<h2 class="text-3xl font-redhat mb-3" id="2">Step 2: Initialize NPM</h2>

In your new project, initialize your project with npm by running the following command:

```bash
npm init
```

This command will prompt you with a series of questions to create a `package.json` file.  
Here's what you should have in your `package.json`:

```json
{
  "name": "Awesome package" /*Name of your package. Need to be unique so look on NPM to see if the name is already taken*/,
  "version": "1.0.0",
  "description": "This is an awesome package",
  "main": "index.js" /*The path to your file with the content of your package is*/,
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "Awesome author",
  "license": "MIT"
}
```

Review the information and make any necessary changes.

</div>

<div>
<h2 class="text-3xl font-redhat mb-3" id="3">Step 3: Prepare Your Package Files</h2>

Ensure that your package files are organized correctly. At a minimum, your package directory should include the following files:

<ul class="list-disc">
<li>**index.ts**: The main entry point of your package, containing the logic you want to share.</li>

<li>
  **package.json**: This file holds essential metadata about your package, such
  as its name, version, dependencies, and more. Make sure the "main" field in
  package.json points to your index.js file.
</li>

<li>
  **README.md**: Create a clear and concise README file that explains what your
  package does, how to use it, and any other relevant information.
</li>

<li>**.gitignore**: In this file add `node_modules` and `dist` to prevent these folders from being added to your GitHub repository.</li>
</ul>
</div>

<div>
<h2 class="text-3xl font-redhat mb-3" id="4">Step 4: Install Packages</h2>

In this step we will add some packages that will be needed during the development of your package.
All these packages will be installed as `devDependencies` so as to avoid bundling them with your package during the build step.
Here are the packages that we will install:

<ul class="list-disc">
  <li>
    **typescript**: A language built on top of Javascript that adds type safety.
    Do not install if you don't want to use it.
  </li>
  <li>
    **tsup**: Bundle your Typescript files to CJS and ESM. Don't install if you
    haven't installed Typescript.
  </li>
  <li>
    **@changesets/cli**: A CLI package that will greatly facilitate versioning
    and publishing your package.
  </li>
  <li>**vitest**: Or any other testing library (Jest, Puppeteer, ...).</li>
</ul>

To install them, run:

```bash
pnpm add -D typescript tsup @changeset/cli vitest
```

</div>

<div>
<h2 class="text-3xl font-redhat mb-3" id="5">Step 5: Initialize Typescript</h2>

After installing all these dependencies, initialize TypeScript by running the following command:

```bash
pnpm tsc --init
```

This command will create a `tsconfig.json` file. In this file, you will find the following content:

```json
{
  "compilerOptions": {
    "target": "es2016" /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */,
    "module": "commonjs" /* Specify what module code is generated. */,
    "esModuleInterop": true /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */,
    "forceConsistentCasingInFileNames": true /* Ensure that casing is correct in imports. */,
    "strict": true /* Enable all strict type-checking options. */,
    "skipLibCheck": true /* Skip type checking all .d.ts files. */
  }
}
```

in this file you will need to add these two lines in `compilerOptions`:

```json
    "noUncheckedIndexedAccess": true, /*Will add undefined to any un-declared field in a type*/
    "noEmit": true /*Will make tsc used only for type checking and not for compilation*/
```

</div>

<div>
<h2 class="text-3xl font-redhat mb-3" id="6">Step 6: Add Scripts</h2>

Now, add the following scripts in your package.json to utilize the various dependencies effectively:

```json
"scripts": {
    "test": "vitest", /*Change if you're using a different tool or remove if you don't have tests setup*/
    "build": "tsup src/index.ts --format cjs,esm --dts", /*Will convert you Typescript files into js and mjs files and will create the .d.ts files*/
    "release": "pnpm build && changeset publish", /*Will be used in the CI to publish your code to NPM*/
    "lint": "tsc", /*Is use to check the Typescript types for errors and warnings*/
    "ci": "pnpm run lint && pnpm run test && pnpm run build" /*Will be used in the CI to ensure that the code is working*/
},
```

Keep the command or change them according to the tools that you use.

</div>

<div>
<h2 class="text-3xl font-redhat mb-3" id="7">Step 7: Add Information About Your Package</h2>

Next, add the following information about your package:

```json
"private": false, /*Must be added to have your package be published on NPM*/
"main": "dist/index.js", /*The dist folder appear after running a build. This specifies where to find the compilled Typescript code. For CJS file*/
"module": "dist/index.mjs", /*For ESM file*/
"types": "dist/index.t.s", /*Where your types are stored so that Typescript users will be able to have access to the types. Skip if you aren't using Typescript*/
"publishConfig": {
    "access": "public"
}, /*Must be added to have your file published on NPM*/
"repository": {
    "type": "git",
    "url": "git+https://github.com/owner/repo.git"
}, /*Url of your repository. Will be shown on a package page under 'Repository'*/
"bugs": {
    "url": "https://github.com/owner/repo/issues"
}, /*Url to the page where users can submit issues or bugs*/
"homepage": "https://github.com/repo/owner#readme", /*Url of the site (or GitHub repo) where the user can find documentation about your package*/
```

Some of these lines are optional but are recommended to add to facilitate the usage of your repo by developers (a package with documentation and easy to find information will be more used than one without)

</div>

<div>
<h2 class="text-3xl font-redhat mb-3" id="8">Step 8: Initialize `changesets`</h2>

Now that everything is setup, let's initialize changesets to make versioning and publishing easy and automatic.  
Start by running this command:

```bash
pnpm changeset init
```

After running this command you will see a new folder called `.changeset`. In this folder you'll find a `config.json` file and a `README.md`.
In the `config.json` you will have all the options to configure Changeset. For now, you only need to change the value of `"access"` from `"restricted"` to `"public"`.

</div>

<div>
<h2 class="text-3xl font-redhat mb-3" id="9">Step 9: Add CI with GitHub Actions</h2>

In this step we will add a CI with GitHub Actions. To do this you will have to create a `.github` folder at the root of your project and, inside this folder, create a `workflows` folder.  
In this new folder you will have two `.yml` file.  
The first file will be called `main.yml` and will have your main CI:

```yaml
name: CI
on:
  push:
    branches:
      - "**"

jobs:
  build:
    name: CI
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: pnpm/action-setup@v2
        with:
          version: 8
      - uses: actions/setup-node@v3
        with:
          node-version: lts/*
          cache: "pnpm"

      - run: pnpm install --frozen-lockfile
      - run: pnpm run ci
```

This workflow will run on every push to any branch and execute linting and tests.  
The second file will be called `publish.yml` and will contain the workflow that will be responsible for publishing your package:

```yaml
name: Publish
on:
  workflow_run:
    workflows: ["CI"]
    types:
      - completed
  push:
    branches:
      - "main"

concurrency: ${{ github.workflow }}-${{ github.ref }}

jobs:
  publish:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    permissions:
      contents: write
      pull-requests: write
    name: Publish
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: pnpm/action-setup@v2
        with:
          version: 8
      - uses: actions/setup-node@v3
        with:
          node-version: lts/*
          cache: "pnpm"

      - run: pnpm install --frozen-lockfile
      - name: Create Release Pull Request or Publish
        id: changesets
        uses: changesets/action@v1
        with:
          publish: pnpm run release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
```

This workflow will run on every push to the `main` branch and will be responsible for publishing your package when the previous workflow succeeds.

</div>

<div>
<h2 class="text-3xl font-redhat mb-3" id="10">Step 10: Select The Right Options For Your GitHub Repository</h2>

In this step, you need to go to your GitHub profile and perform the following actions:

<ul class="list-disc">
  <li>
    Go to `Settings > Actions > General > Worflow permissions` and check that
    "Read and write permissions" and "Allow GitHub Actions to create and approve
    pull requests" are checked.
  </li>
  <li>
    Go to your NPM account and create a new access token. Once you have it go
    back to GitHub and under `Settings > Secrets and variables > Actions`
    declare a new repository secret called "NPM_TOKEN" (the same name than the
    one passed in the env of the publish workflow) with the secret being the
    access token value.
  </li>
  <li>
    Install the changeset bot on your repository. To do so go to this
    [page](https://github.com/apps/changeset-bot) click on "Configure" and then
    choose the repository on which you want to install it. This bot will add a
    comment to pull requests saying that it detected the presence (or absence)
    of a changeset.
  </li>
</ul>

</div>

<div>
<h2 class="text-3xl font-redhat mb-3" id="11">Step 11: Publish Your Empty Package</h2>

Now that everything is setup you will have to publish the first version of your package.  
To do so you will have to login into your NPM account by running this command:

```bash
npm login
```

This command will ask you to enter your NPM account credentials.  
After that you need to build your package by running the build command:

```bash
pnpm build
```

When done you can publish you code by running this command:

```bash
npm publish
```

It will publish your package to a NPM registry. You can go to your NPM account to check that your package is here.

</div>

<div>
<h2 class="text-3xl font-redhat mb-3" id="12">Step 12: Write Your Code</h2>

In this step you will finally be able to write the code of your package.  
Before you will have to create a new branch with this command:

```bash
git checkout -b <branch name>
```

Next write the code for your awesome new package and write some tests to check that it's working correctly.  
Once done you will need to bump the version of your package and that's where you will use changset. Run the following command:

```bash
pnpm changeset
```

It will ask you if your change is major, minor or just a patch. You can find an in-depth guide for the semantic versioning on [semver.org](https://semver.org/) but here are the main differences between these terms:

<ul class="list-disc">
  <li>
    **patch**: Will increment the last number of the version. Used when you
    introduce backward compatible bug fixes.
  </li>
  <li>
    **minor**: Will increment the middle number of the version. Used when you
    introduce new backward compatible functionality.
  </li>
  <li>
    **major**: Will increment the first number of the version. Used when you
    introduce backward incompatible changes.
  </li>
</ul>
After that it will ask you to describe the changes (the description will appear in
the CHANGELOG.md file) Now you should see a new markdown file in `.changeset` with
a weird name (the name is generated with random words to prevent merge conflict).
Commit the changes and push it. If you go in your repository on GitHub under the
Actions tab you should see the CI (or whatever name you gave to the workflow in the
`main.yml` file) workflow running but not the Publish one. If the CI workflow succeed
you can open a pull request to merge the changes into the main branch.

</div>

<div>
<h2 class="text-3xl font-redhat mb-3" id="13">Step 13: Bump The Version</h2>

In the new pull request you should see a comment made by the changeset bot saying that it detected a changeset (if not verify that you have commited the markdown file previously created by changeset).  
If everything is fine merge the pull request and you should see a new pull request created automatically named "Version Packages". If you check the details of this pull request you should see that it removes the markdown file, changes the version in the `package.json` file and create (or update) the `CHANGELOG.md` file which will serve as a summary of all the releases you made.  
Merge this pull request and you should have a new version of your package released.

</div>

<div>
<h2 class="text-3xl font-redhat mb-3" id="13">Step 13: Bump The Version</h2>

Congratulations! You've successfully published your npm package, making it accessible to developers worldwide.

</div>
